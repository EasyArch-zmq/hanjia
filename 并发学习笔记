Java学习：
1.进程:
  线程:

2.并发:(单核cpu同一时间应对多个事情)每一个线程都是有许多指令组成,所有指令全部执行完,一个线程执行完.
操作系统有一个组件叫任务调度器:把cpu的时间分给不同的线程使用,就是让多个线程轮流去使用
cpu

  并行:(多核CPU,每个核可以处理一个线程的指令,多核同时处理多个线程指令)
多数时候都是并行并发同时存在的,因为往往是线程数比核心数要多.

(应用1:)异步调度:

同步异步都是从方法调用的角度讲的.
	同步:需要等待结果返回才能继续运行.
	异步:不需要等待结果返回就可以继续运行.
(应用2:)提高效率
	可以充分利用多核CPU的优势,提高运行效率.

创建线程:
1.new Thread();
2.Runnable r=new Runnable();是任务对象.run方法里写任务.
new Thread(r);
第二种,线程和任务分开.
3.FutureTask配合Callable类型的参数,FutureTask接收Callable类型的对象,用来处理返回值结果的情况:仍然是任务和线程分开,FutureTask作为Thread()的参数去运行.

栈和栈帧:
  jvm由堆,栈,方法区组成.其中栈是给线程用的,每一个线程启动,虚拟机都会给线程分配一块栈内存
  每个线程的栈内存是相互独立的,互不影响.
  每个栈又是由多个栈帧组成,对应着每次方法调用时锁占的内存
  每个线程只能有一个活动栈帧,对应当前调用的方法
  栈内存是在执行完方法就会被释放.

线程的上下文切换(Thread Context Switch)
	从使用CPU到不适用CPU的过程成为一次上下文切换.
	CPU不执行程序的原因:
		线程CPU时间片用完了
		垃圾回收
		有更高优先级的线程需要运行
		线程自己调用了sleep,yield,wait,join,park,synchronized,lok等方法
	Context Switch发生时,需要操作系统保存当前的线程状态,并且恢复另一个线程的状态
	Java中使用程序计数器(Program Counter Register)
	  记住下一条jvm指令的执行地址,是每个线程私有的
    状态:程序计数器,虚拟机栈中每个栈帧的信息,如局部变量,操作数栈,返回地址等
    频繁地上下文切换影响性能.

线程方法:
	star()方法调用只是让线程进入就绪状态,是否运行是取决于任务调度器(是否得到CPU的时间片
	wait()
	join()等待线程运行结束(有参数就是指定等待的毫秒数),底层原理就是wait,wait,join就是一回事
	睡眠结束的线程不一定立刻运行,是否运行取决于CPU时间片是否给它了
	interrupt()方法,1.打断阻塞的线程(sleep,wait,join).
					2.打断正在运行的线程
	结合打断标记一起使用.

	停止其他线程的方式:两阶段终止模式
	    就是给被终止线程一个处理后事的机会.
	    后台监控线程就用了这个方法.
	isinterrupt():判断是否被打断,不会清楚打断标记
	interrupted():也是判断是否被打断,贵清楚打断标记.

	错误做法:
	1.使用stop()强制杀死线程,如果线程正锁住了共享内存,那么被杀死后再也没有机会释放锁,其他线程永远无法获得锁.
	2.使用System.exit(int)方法停止线程(太暴力,没必要)
	   这种方法会停止整个程序,但其实我们只需要停止一个线程就可以了.


线程状态:
是从操作系统的层面说的:
五个状态:
  1.初始状态:只是在语言层面创建了线程对象,还没有和操作系统线程关联
  2.可运行状态即就绪状态:线程对象不确实被创建了,于操作系统线程关联了,等待CPU调度执行
  3.运行状态:已经被CPU调度,就是获得了CPU分配的时间片,正在运行的状态
    当CPU分配的时间片用完了,就一位置线程要回到就绪状态,等待下一个时间片,因此导致线程的
    上下文切换
   4.阻塞状态:
     如果调用了阻塞API,如BIO读写文件,这时候线程实际不需要用到CPU,会主动放弃CPU使用权,
     进行上下文切换,进入阻塞状态.
     等到BIO操作完成,由操作系统唤醒阻塞的线程,进入就绪状态.
    5.结束状态:线程执行完毕,生命周期结束,不会转换状态了.


第四章共享模型:
	1.共享问题
	2.synchronized
	3.线程安全分析
	4.Monitor
	5.wait/notify
	6.线程状态转换
	7.活跃性
	8.Lock

1.由于分时系统造成的线程切换导致的安全问题.
例如两个线程,一个做i++操作,另一个左i--操作.
为什么会出现线程安全,是因为这两个操作并不是由一个指令来完成的.
i++jvm指令:
getstatic i 获取静态变量i的值
inconst_1   准备一个常量1
iadd        自增
putstatic i 将修改后的值存入静态变量i

i--的jvm指令
getstatic i 获取静态变量i的值
inconst_1   准备一个常量1
isub        自减
putstatic i 将修改后的值存入静态变量i


2.因为上下文切换会产生指令交错.
	如果多个线程通知执行读取共享资源,是没有问题的
	但多个线程对共享内存进行读写操作,发生指令交错,就会出问题
3.为避免这中问题产生(也叫发生临界区的竞态条件)右两种方案:
	阻塞式解决方案:synchronized(对象锁,使用互斥的方式让同一时刻只有一个线程拥有对象锁),其他线程如果要使用对象锁,就会进入阻塞状态,等到被释放锁的线程唤醒以后才能获得锁,lock
	加了synchronized的代码段就是串行执行的.
	非阻塞式解决方案:原子变量
	synchronized就是用对象锁保证临界区代码块的原子性.使这部分代码成为不可分割的整体,不会因为上下文切换被分割.
	多个线程要加锁必须都对同一个对象加锁,否则没有枷锁的线程不会阻塞,会继续执行.仍然解决不了问题.
	方法上加synchronized锁的是this对象
	方法上加static synchronized锁的是类对象

变量的线程安全:
	成员变量和静态变量如果没有共享,线程是安全的;
		如果只发生读操作,线程也是安全的.
		如果发生读写操作,那么这段代码是属于临界区,需要考虑线程安全
	局部变量是线程安全的.
	但局部变量的引用对象就不一定:
		如果这个对象没有逃离方法的作用访问,是线程安全的;
		如果逃离了方法的作用访问,需要考虑线程安全.

不可变类是线程安全的:
	String
	Integer
	.....
	因为只读不可以改变,就不会右线程安全问题.
	String底层实现改值是通过new 一个新的对象,并复制一份原来的值,然后改值后赋值给访问对象.
	String中加final是为了线程安全,避免子类修改父类中的一些行为.

Monitor(锁)对象(是操作系统提供的):
	翻译为监视器或管程.
	获得锁后,MarkWord(原本是存了hascode和分代年龄,还有锁状态为01,就是正常时无锁),变成不再存储hascode和分代年龄,锁状态改成10,存储了一个指向Monitor对象的指针.
	此时的线程就成为Monitor的所有者,若此时再来一个线程请求锁,就要先检查obj是否关联了Monitor,并切检查Monitor的owner有没有线程,如果有,就会挂上Monitor的等待队列(EntryList).





